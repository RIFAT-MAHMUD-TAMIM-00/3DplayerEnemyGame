# -*- coding: utf-8 -*-
"""21201787_Rifat_Mahmud_Tamim_Assignment03

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fXJeATOKmlOrMcARofxcehscN38oNdIR
"""

from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
import random
from math import  sin,radians,cos,sqrt,degrees,atan2


position = [0, 0, 0]
player_rotation = 0
player_size = 30
player_spawned = False
cam_distance = 500
cam_height=300
cam_angle=180  # Initial camera position (distance, height, angle)
fovY = 120  # Field of view in degrees
GRID_LENGTH = 600
rand_var = 423

third_person =(500,300,0)
perspective="THIRD_PERSON"

bullets =[]
player_speed =3
rotation_speed=2
bullet_speed =1
bullet_size=12


enemies=[]
pulsing_size=0
pulsing_speed=0.5
enemy_baseSize=20

live = 5
score = 0
miss_bullet = 0
game_over = False



cheat_mode=False
follow=False
cheat_speed=1

def is_inside_bounds(x, y, margin=player_size):
    return (-GRID_LENGTH + margin <= x <= GRID_LENGTH - margin and
            -GRID_LENGTH + margin <= y <= GRID_LENGTH - margin)

def keyboardListener(key, x, y):

    global position,player_rotation,rotation_speed,live,miss_bullet, score, game_over, enemies, bullets, cheat_mode, follow,cheat_speed


    # # Move forward (W key)
    if key == b'w':
        new_x = position[0] + cos(radians(player_rotation)) * player_speed
        new_y = position[1] + sin(radians(player_rotation)) * player_speed
        if is_inside_bounds(new_x, new_y):
            position[0], position[1] = new_x, new_y

    if key == b's':
        new_x = position[0] - cos(radians(player_rotation)) * player_speed
        new_y = position[1] - sin(radians(player_rotation)) * player_speed
        if is_inside_bounds(new_x, new_y):
            position[0], position[1] = new_x, new_y

    # Rotate left (A key)
    if key == b'a':
        player_rotation += rotation_speed
        player_rotation %= 360

    # Rotate right (D key)
    if key == b'd':
        player_rotation -= rotation_speed
        player_rotation %= 360



    if key == b'c':
        cheat_mode = not cheat_mode  # Toggle cheat mode
        if not cheat_mode:
            follow = False


    if key == b'v' and cheat_mode:
        follow = not follow

    if game_over==True and key == b'r':
        live = 5
        score = 0
        miss_bullet = 0
        game_over = False
        bullets = []
        position = [0, 0, 0]
        initialize_enemy()
        glutPostRedisplay()
        return
    if game_over:
        return

    glutPostRedisplay()


def cheat_behavior():
    global player_rotation, bullets

    if not cheat_mode:
        return

    # Continuous rotation
    player_rotation += cheat_speed
    player_rotation %= 360

    for enemy in enemies:

        dx = enemy['x'] - position[0]
        dy = enemy['y'] - position[1]
        enemy_angle = degrees(atan2(dy, dx)) % 360

        # Check if enemy is roughly in front (within 15 degrees)
        if abs((enemy_angle - player_rotation + 180) % 360 - 180) < 15:

            length = 50
            x_bull = position[0] + cos(radians(player_rotation)) * length
            y_bull = position[1] + sin(radians(player_rotation)) * length

            bullets.append({
                'x': x_bull,
                'y': y_bull,
                'z': 150,
                'angle': player_rotation,
                'speed': bullet_speed * 1.5  # Faster bullets in cheat mode
            })
            break


def check_collisions():
    global live, score, miss_bullet, game_over, bullets, enemies
    #bullet-enemy
    for i in bullets[:]:
        for j in enemies[:]:
            dx = i['x']- j['x']
            dy = i['y'] - j['y']
            distance = sqrt(dx*dx + dy*dy)

            if distance < enemy_baseSize * 1.5:  # Collision detected
                score += 10
                bullets.remove(i)

                j['x'] = random.randint(-(GRID_LENGTH-100), (GRID_LENGTH-100))
                j['y'] = random.randint(-(GRID_LENGTH-100), (GRID_LENGTH-100))
                break

    # Player-enemy collisions
    for enemy in enemies:
        dx = position[0] - enemy['x']
        dy = position[1] - enemy['y']
        distance = sqrt(dx*dx + dy*dy)

        if distance < enemy_baseSize + player_size:
            live -= 1
            # Push enemy away
            enemy['x'] = random.randint(-(GRID_LENGTH-100), (GRID_LENGTH-100))
            enemy['y'] = random.randint((GRID_LENGTH-100), (GRID_LENGTH-100))

    # Count missed bullets
    for bullet in bullets[:]:
        if abs(bullet['x']) > GRID_LENGTH or abs(bullet['y']) > GRID_LENGTH:
            miss_bullet += 1
            bullets.remove(bullet)

    # Check game over conditions
    if live <= 0 or miss_bullet >= 10:
        game_over = True

def draw_text(x, y, text, font=GLUT_BITMAP_HELVETICA_18):
    glColor3f(1,1,1)
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()


    gluOrtho2D(0, 1000, 0, 800)  # left, right, bottom, top


    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()

    # Draw text at (x, y) in screen coordinates
    glRasterPos2f(x, y)
    for ch in text:
        glutBitmapCharacter(font, ord(ch))


    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)

def draw_player():
    glPushMatrix()  # Main player matrix
    glTranslatef(position[0], position[1], 0)

    if game_over:
        glRotatef(90, 1, 0, 0)  # Rotate to lie down

    else:
        glRotatef(player_rotation, 0, 0, 1)
        glRotatef(-90, 0, 0, 1)  # Makes player face forward

        # LEGS (vertical cylinders)
    leg_positions = [-15, 15]
    glColor3f(0, 0, 1)  # Blue legs
    for x in leg_positions:
        glPushMatrix()
        glTranslatef(x, 0, 0)
        glRotatef(-90, 0, 0, 1)  # Make legs vertical
        gluCylinder(gluNewQuadric(), 10, 25, 100, 10, 10)
        glPopMatrix()

        # BODY (centered cube)
    glPushMatrix()
    glColor3f(0.138, 0.558, 0.321)  # Green body
    glTranslatef(0, 0, 150)
    glScalef(1, 0.5, 1)
    glutSolidCube(90)
    glPopMatrix()

        # ARMS (horizontal cylinders)
    arm_positions = [-40, 40]
    glColor3f(0.9, 0.9, 0.6)  # Skin color
    for x in arm_positions:
        glPushMatrix()
        glTranslatef(x, 0, 150)
        glRotatef(-90, 1, 0, 0)
        gluCylinder(gluNewQuadric(), 20, 10, 80, 10, 10)
        glPopMatrix()

        # GUN (centered forward)
    glPushMatrix()
    glColor3f(0.5, 0.5, 0.5)  # Gray gun
    glTranslatef(0, 0, 150)
    glRotatef(-90, 1, 0, 0)
    gluCylinder(gluNewQuadric(), 20, 10, 100, 10, 10)
    glPopMatrix()

        # HEAD (top sphere)
    glPushMatrix()
    glColor3f(0, 0, 0)  # Black head
    glTranslatef(0, 0, 230)
    gluSphere(gluNewQuadric(), 40, 15, 15)
    glPopMatrix()

    glPopMatrix()  # Final pop for main player matrix

def initialize_enemy():
    global enemies
    enemies=[]
    for i in range(5):
        en_x=random.randint(-(GRID_LENGTH-100),(GRID_LENGTH-100))
        en_y=random.randint(-(GRID_LENGTH-100),(GRID_LENGTH-100))
        en_z=0
        enemies.append({
            'x': en_x,
            'y': en_y,
            'z': en_z,
            'size': enemy_baseSize,
            'speed': random.uniform(0.01,0.03 )
        })

def draw_enemy():
    """Draw all enemies with pulsing effect"""
    global pulsing_size

    pulsing_size += pulsing_speed
    pulse_factor = 0.2 * sin(radians(pulsing_size))

    for en in enemies:
        glPushMatrix()
        glTranslatef(en['x'], en['y'], en['z'])

        current_size =enemy_baseSize*(1 + pulse_factor)
        glColor3f(1, 0, 0)
        gluSphere(gluNewQuadric(), current_size, 20, 20)

        # Head
        glColor3f(0, 0,0)
        glTranslatef(0, 0, current_size * 1.2)
        gluSphere(gluNewQuadric(), current_size * 0.6, 20, 20)

        glPopMatrix()

    glutPostRedisplay()

def move_enemy():
    """Make enemies move toward player"""
    for i in enemies:
        # Calculate direction vector to player
        hor_x = position[0] - i['x']
        ver_y = position[1] - i['y']
        distance = max(0.1, sqrt(hor_x*hor_x + ver_y*ver_y))  # Avoid division by zero

        i['x'] += (hor_x/distance) * i['speed']
        i['y'] += (ver_y/distance) * i['speed']


def specialKeyListener(key, x, y):

    global cam_height, cam_angle

    min_y = 100
    max_y = 1000
    min_x = -1000
    max_x = 1000

    # Move camera up
    if key == GLUT_KEY_UP and cam_height>min_y:
    # if key == GLUT_KEY_UP:
        cam_height += 10
        cam_height=min(cam_height, 800)

    # Move camera down
    elif key == GLUT_KEY_DOWN and cam_height<max_y:
    # elif key == GLUT_KEY_DOWN:
        cam_height -= 10
        cam_height = max(cam_height, 100)

    # Move camera left
    elif key == GLUT_KEY_LEFT and cam_angle > min_x :
        cam_angle += 10
        cam_angle %= 360

    # Move camera right
    elif key == GLUT_KEY_RIGHT and cam_angle < max_x:
        cam_angle += 10
        cam_angle %= 360

    glutPostRedisplay()


def mouseListener(button, state, x, y):
    """
    Handles mouse inputs for firing bullets (left click) and toggling camera mode (right click).
    """
    global bullets,perspective

    if button == GLUT_RIGHT_BUTTON and state == GLUT_DOWN:

        if perspective == "THIRD_PERSON":
            perspective = "FIRST_PERSON"


        else:
            perspective="THIRD_PERSON"
        glutPostRedisplay()
        # # Left mouse button fires a bullet
    if button == GLUT_LEFT_BUTTON and state == GLUT_DOWN:
        length=50
        x_bull = position[0] + cos(radians(player_rotation)) *length
        y_bull = position[1] + sin(radians(player_rotation)) * length

        bullets.append({
            'x': x_bull,
            'y': y_bull,
            'z': 150,
            'angle': player_rotation,
            'speed': bullet_speed
        })

    glutPostRedisplay()

def draw_bullets():

    global bullets

    for i in bullets[:]:
        i['x'] += cos(radians(i['angle'])) * i['speed']
        i['y'] += sin(radians(i['angle'])) * i['speed']

        # Draw bullet (small cube)
        glPushMatrix()
        glColor3f(1, 0, 0)  # Yellow color
        glTranslatef(i['x'], i['y'], i['z'])  # Slightly above ground
        glutSolidSphere(bullet_size, 8, 8)  # Small cube for bullet
        glPopMatrix()

        # Remove bullets that go off-screen
        if (abs(i['x']) > GRID_LENGTH or
            abs(i['y']) > GRID_LENGTH):
            bullets.remove(i)

    glutPostRedisplay()
def setupCamera():
    """
    Configures the camera's projection and view settings.
    Uses a perspective projection and positions the camera to look at the target.
    """
    global cam_distance, cam_height, cam_angle
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()

    gluPerspective(fovY, 1.25, 0.1, 1500)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()

    if perspective == "THIRD_PERSON":
        if cheat_mode and follow:

            cam_angle = player_rotation + 180



            new_x=position[0] - cam_distance*cos(radians(cam_angle))
            new_y = position[1] - cam_distance * sin(radians(cam_angle))

            gluLookAt(new_x, new_y, cam_height,  # Camera position
                position[0], position[1], 100,  # Look-at target
                0, 0, 1)  # Up vector (z-axis)

        else:
            # Normal third-person camera
            new_x = position[0] - cam_distance * cos(radians(cam_angle))
            new_y = position[1] - cam_distance * sin(radians(cam_angle))
            gluLookAt(new_x, new_y, cam_height,
                     position[0], position[1], 100,
                     0, 0, 1)
    else:

        dir_x = position[0] + cos(radians(player_rotation)) * 100  # Look direction
        dir_y = position[1] + sin(radians(player_rotation)) * 100


        gluLookAt(position[0] + cos(radians(player_rotation)) * 30, position[1] + sin(radians(player_rotation)) * 30, 180,
                 dir_x, dir_y, 180,
                 0, 0, 1)


def idle():
    """
    Idle function that runs continuously:
    - Triggers screen redraw for real-time updates.
    """
    # Ensure the screen updates with the latest changes
    if game_over ==False:
        draw_bullets()
        move_enemy()
        check_collisions()
        cheat_behavior()
    glutPostRedisplay()

def draw_grid():
    cell_length = 120
    cells = GRID_LENGTH// cell_length

    for x in range(-cells, cells):
        for y in range(-cells, cells):
            if (x+y) % 2 == 0:
                glColor3f(0.7, 0.5, 0.95)
            else:
                glColor3f(1, 1, 1)
            glBegin(GL_QUADS)
            glVertex3f(x*cell_length,y* cell_length,0)
            glVertex3f((x +1)*cell_length, y* cell_length, 0)
            glVertex3f((x+1)*cell_length, (y+1)*cell_length,0)
            glVertex3f(x*cell_length,(y+1)*cell_length,0)
            glEnd()

def border():
    wall_height =100
    glColor3f(0, 1, 1)
    glBegin(GL_QUADS)
    glVertex3f(-GRID_LENGTH, -GRID_LENGTH, 0)
    glVertex3f(GRID_LENGTH, -GRID_LENGTH, 0)
    glVertex3f(GRID_LENGTH, -GRID_LENGTH, wall_height)
    glVertex3f(-GRID_LENGTH, -GRID_LENGTH, wall_height)

    glEnd()
# North wall (top side)
    glColor3f(1,1,1)
    glBegin(GL_QUADS)
    glVertex3f(-GRID_LENGTH, GRID_LENGTH, 0)
    glVertex3f(GRID_LENGTH, GRID_LENGTH, 0)
    glVertex3f(GRID_LENGTH, GRID_LENGTH, wall_height)
    glVertex3f(-GRID_LENGTH, GRID_LENGTH, wall_height)
    glEnd()

    glColor3f(0, 1, 0)
    glBegin(GL_QUADS)
    glVertex3f(-GRID_LENGTH, -GRID_LENGTH, 0)
    glVertex3f(-GRID_LENGTH, GRID_LENGTH, 0)
    glVertex3f(-GRID_LENGTH, GRID_LENGTH, wall_height)
    glVertex3f(-GRID_LENGTH, -GRID_LENGTH, wall_height)
    glEnd()

    glColor3f(0, 0, 1)
    glBegin(GL_QUADS)
    glVertex3f(GRID_LENGTH, -GRID_LENGTH, 0)
    glVertex3f(GRID_LENGTH, GRID_LENGTH, 0)
    glVertex3f(GRID_LENGTH, GRID_LENGTH, wall_height)
    glVertex3f(GRID_LENGTH, -GRID_LENGTH, wall_height)
    glEnd()



def showScreen():
    """
    Display function to render the game scene:
    - Clears the screen and sets up the camera.
    - Draws everything of the screen
    """
    # Clear color and depth buffers
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glLoadIdentity()  # Reset modelview matrix
    glViewport(0, 0, 1000, 800)  # Set viewport size

    setupCamera()  # Configure camera perspective

    # Draw a random points
    glPointSize(20)
    glBegin(GL_POINTS)
    glVertex3f(-GRID_LENGTH, GRID_LENGTH, 0)
    glEnd()


    draw_grid()
    border()
    # Display game info text at a fixed screen position
    draw_text(10, 770, f"Lives: {live}  Score: {score}  Missed: {miss_bullet}")
    if game_over:
        draw_text(10, 750, "GAME OVER - Press R to restart", GLUT_BITMAP_TIMES_ROMAN_24)
    draw_player()
    draw_bullets()
    draw_enemy()
    glutSwapBuffers()


# Main function to set up OpenGL window and loop
def main():
    glutInit()
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)  # Double buffering, RGB color, depth test
    glutInitWindowSize(1000, 800)  # Window size
    glutInitWindowPosition(0, 0)  # Window position
    wind = glutCreateWindow(b"3D OpenGL Intro")  # Create the window

    glutDisplayFunc(showScreen)  # Register display function
    glutKeyboardFunc(keyboardListener)  # Register keyboard listener
    glutSpecialFunc(specialKeyListener)
    glutMouseFunc(mouseListener)
    glutIdleFunc(idle)
    initialize_enemy()
    glutMainLoop()
if __name__ == "__main__":
    main()